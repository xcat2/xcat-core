#!/usr/bin/env perl
BEGIN
{
    $::XCATROOT = $ENV{'XCATROOT'} ? $ENV{'XCATROOT'} : '/opt/xcat';
}
use lib "$::XCATROOT/lib/perl";

use File::Basename;
use File::Path;
use File::Copy qw/copy cp mv move/;
use File::Find;
use Getopt::Long;
use Cwd qw(realpath);
use File::Temp qw/mkdtemp/;

use FindBin;
use lib "$FindBin::Bin/../imgutils";
use imgutils;

#use strict;
Getopt::Long::Configure("bundling");
Getopt::Long::Configure("pass_through");

my $prinic; #TODO be flexible on node primary nic
my $othernics; #TODO be flexible on node primary nic
my $netdriver;
my @yumdirs;
my $arch;
my %libhash;
my @filestoadd;
my $profile;
my $osver;
my $pathtofiles=dirname($0);
my $fullpath=realpath($pathtofiles);
my $name = basename($0);
my $onlyinitrd=0;
#that this method of calling genimage is no longer used
if ($name =~ /geninitrd/) {
   $onlyinitrd=1;
}
my $rootlimit;
my $tmplimit;
my $installroot = "/install";
my $kerneldir;
my $kernelver = ""; 
my $basekernelver; 
my $customdir=$fullpath;
$customdir =~ s/.*share\/xcat/$installroot\/custom/;
my $imagename;
my $pkglist;
my $srcdir;
my $destdir;
my $srcdir_otherpkgs;
my $otherpkglist;
my $postinstall_filename;
my $rootimg_dir;
my $mode;
my $permission; #the permission works only for statelite mode currently
my $krpmver;
my $tempfile;
my $prompt;
my $timezone; #the TIMEZONE of the stateless and statelite node

sub xdie {
   system("rm -rf /tmp/xcatinitrd.$$");
   die @_;
}

#-- fetch current version form CVS (overwrite locally changed versions)
# if (opendir(CVS,"$pathtofiles/CVS")){
#   close CVS;
#   my $cvsout = qx/cd $pathtofiles; cvs update -C 2>&1/;
#   chomp $cvsout;
#   if ( $cvsout ne "cvs update: Updating ." ) {
#     print "Difference of local copy from CVS detected\n";
#     print $cvsout,"\n";
#     print "Trying to re-run $name\n";
#     print("$pathtofiles/$name ",join(" ",@ARGV),"\n");
#     exec("$pathtofiles/$name",@ARGV);
#   }
# }


$SIG{INT} = $SIG{TERM} = sub { xdie "Interrupted" };
GetOptions(
   'a=s' => \$arch,
   'p=s' => \$profile,
   'o=s' => \$osver,
   'n=s' => \$netdriver,
   'i=s' => \$prinic,
   'r=s' => \$othernics,
   'l=s' => \$rootlimit,
   't=s' => \$tmplimit,
   'k=s' => \$kernelver,
   'g=s' => \$krpmver,
   'permission=s' => \$permission,
   'kerneldir=s' => \$kerneldir,   
   'timezone=s'  => \$timezone,   
   'tempfile=s' =>\$tempfile, #internal flag
   'pkglist=s' => \$pkglist,   #internal flag
   'srcdir=s' => \$srcdir,   #internal flag
   'otherpkgdir=s' => \$srcdir_otherpkgs,  #internal flag
   'otherpkglist=s' => \$otherpkglist,      #internal flag
   'postinstall=s' => \$postinstall_filename,  #internal flag
   'rootimgdir=s' => \$destdir,   #internal flag
   'driverupdatesrc=s' => \$driverupdatesrc, #internal flag
   'interactive' =>\$prompt, 
   'onlyinitrd' =>\$onlyinitrd,
 );

if (@ARGV > 0) {
    $imagename=$ARGV[0];
}


my %updates_os = ();    # the hash for updating osimage table
my %updates = ();       # the hash for updating linuximage table


$permission = "755" unless ($permission);
$updates{'permission'} = $permission if ($tempfile);

unless ($arch) {
    $arch = `uname -m`;
    chomp($arch);
    $arch = "x86" if ($arch =~ /i.86$/);
}

$srcdir="$installroot/$osver/$arch" unless ($srcdir);
$updates{'pkgdir'} = $srcdir if ($tempfile);
#$srcdir = $srcdir . "/1";

$srcdir_otherpkgs = "$installroot/post/otherpkgs/$osver/$arch" unless ($srcdir_otherpkgs); 
$updates{'otherpkgdir'} = $srcdir_otherpkgs if ($tempfile);

$destdir="$installroot/netboot/$osver/$arch/$profile" unless ($destdir);
$updates{'rootimgdir'} = $destdir if ($tempfile);

$rootimg_dir="$destdir/rootimg";

if ($kernelver && (!$krpmver)) {
    print "The -g flag for the rpm version of kernel packages needs to be specified when kernel version has been specified.\n";
    exit 1;
}
$kerneldir = "$installroot/kernels" unless ($kerneldir);    # the default directory for 3rd-party kernel is "$installroot/kernels";
#$updates{'kerneldir'} = $kerneldir if ($tempfile);

unless ($osver and $profile) {
    usage();
    exit 1;
}
my @ndrivers;

if ($netdriver) {
    foreach (split /,/,$netdriver) { 
        if (/^allupdate$/) {
            next;
        }
        unless (/\.ko$/) {
    	      s/$/.ko/;
        }
        next if (/^$/);
        
        # Do not include qeth module here
        # This module is included later on
        unless ( $_ =~ m/qeth/i ) {
    	      push @ndrivers, $_;
        }
    }

    if ( ($updates{'netdrivers'} ne $netdriver) and $tempfile ) {
        $updates{'netdrivers'} = $netdriver;
    }
}

# Use the default list if not specified
unless (@ndrivers) {
    if ($arch eq 'x86' or $arch eq 'x86_64') {
        @ndrivers = qw/tg3 bnx2 bnx2x e1000 e1000e igb mlx_en be2net/;
    } elsif ($arch eq 'ppc64') {
        @ndrivers = qw/tg3 e1000 e1000e igb ibmveth ehea be2net/;
    } elsif ($arch eq "s390x") {
        @ndrivers = qw/qdio ccwgroup qeth qeth_l2 qeth_l3/;
    }
}

foreach (@ndrivers) {
   unless (/\.ko$/) {
      s/$/.ko/;
   }
}

unless (grep /af_packet/,@ndrivers) {
    unshift(@ndrivers,"af_packet.ko");
}

my $osver_host;
if(`grep VERSION /etc/SuSE-release` =~ /VERSION = (\d+)/) {
    $osver_host=$1;
} else {
    $osver_host=11;
}

unless ($onlyinitrd) {

    # now, let's handle the extra packages
    unless ($imagename) {
        $otherpkglist=imgutils::get_profile_def_filename($osver, $profile, $arch, $customdir, "otherpkgs.pkglist");
        unless ($otherpkglist) { $otherpkglist=imgutils::get_profile_def_filename($osver, $profile, $arch, $pathtofiles, "otherpkgs.pkglist"); }
        $updates{'otherpkglist'} = $otherpkglist if ($tempfile and $otherpkglist);
    }
    my %extra_hash=();
    %extra_hash=imgutils::get_package_names($otherpkglist) if ($otherpkglist);


    # prepare the chroot environment for the root image

    mkpath "$rootimg_dir/etc";
    mkpath "$rootimg_dir/dev";
    #system "mount -o bind /dev $rootimg_dir/dev";
    unless ( -e "$rootimg_dir/dev/zero") {
        system "mknod $rootimg_dir/dev/zero c 1 5";
    }
    unless ( -e "$rootimg_dir/dev/null") {
        system "mknod $rootimg_dir/dev/null c 1 3"; #that's neccessary for SLES11
    }

    unless ( -e "$rootimg_dir/dev/random") {
        system "mknod $rootimg_dir/dev/random c 1 8"; #that's neccessary for SLES11
    }
    unless ( -e "$rootimg_dir/dev/urandom") {
        system "mknod $rootimg_dir/dev/urandom c 1 9"; #that's neccessary for SLES11
    }

    for (my $i = 0; $i <= 12; $i++)
    {
        unless ( -e "$rootimg_dir/dev/tty$i") {
            system "mknod $rootimg_dir/dev/tty$i c 4 $i"; #that's neccessary for SLES11
        }
    }

   open($fd,">>","$rootimg_dir/etc/fstab"); # TODO: is it necessary?
   print $fd "#Dummy fstab for rpm postscripts to see\n";
   close($fd);
   
   my $non_interactive;
   if (!$prompt) { $non_interactive="--non-interactive --no-gpg-checks"; }

   if($osver_host == 11) {#zypper in SLES11 is different

       system("rm -rf $rootimg_dir/etc/zypp/repos.d/$osver-*.repo");
       my @pkgdirs = split(",", $srcdir); 
       my $dir;
       my $i = 0; 
       # To support multiple paths for osimage.pkgdir
       foreach $dir (@pkgdirs) {
           if( -d "$dir/1") {
               $dir .= "/1"; 
           }
           system("zypper -R $rootimg_dir $non_interactive ar file:$dir $osver-$i");
           $i++;
       }

       #if(-e "$rootimg_dir/etc/zypp/repos.d/$osver.repo") {
       #    system("rm -rf $rootimg_dir/etc/zypp/repos.d/$osver.repo");
       #}
       #system("zypper -R $rootimg_dir $non_interactive ar file:$srcdir $osver");
       #if(-e "$rootimg_dir/etc/zypp/repos.d/${osver}sdk.repo") {
       #    system("rm -rf $rootimg_dir/etc/zypp/repos.d/${osver}sdk.repo");
       #}
       my $srcdir_sdk  = "$installroot/$osver/$arch/sdk1";
       if ( -e "$srcdir_sdk") {
           system("zypper -R $rootimg_dir $non_interactive ar file:$srcdir_sdk ${osver}sdk");
       }

   }else {
           $srcdir = $srcdir . "/1";
	   system("zypper -R $rootimg_dir $non_interactive sa file:$srcdir");
   }

   # Add the rep for kernel packages
   if ($kernelver) {
      if (! -d $kerneldir) {
          print "Cannot find the directory for the kernel at $kerneldir.\n";
          exit 1;
      }
      if ($osver_host == 11) {
         if (-e "$rootimg_dir/etc/zypp/repos.d/$kernelver.repo") {
            system("rm -rf $rootimg_dir/etc/zypp/repos.d/$kernelver.repo");
         }
         system("zypper -R $rootimg_dir $non_interactive ar file:$kerneldir $kernelver");
      } else {
         system("zypper -R $rootimg_dir $non_interactive sa file:$kerneldir");
      }
   }

   #remove the old repository for extra packages
   if ($osver_host == 11) {
       my $result=`zypper -R $rootimg_dir $non_interactive lr |grep otherpkg|cut -f2 -d '|'|tr "\n" " "`;
       if ($result =~ /\S/) {
           system("zypper -R $rootimg_dir $non_interactive rr $result");
       }
   } else {
       my $result=`zypper -R $rootimg_dir $non_interactive sl |grep otherpkg|cut -f2 -d '|'|tr "\n" " "`;
       if ($result =~ /\S/) {
           system("zypper -R $rootimg_dir $non_interactive sd $result");
       }
   }

   #add the new repository for extra packages
   my %extrapkgnames; 
   if($osver_host == 11) {	#SLES11
       if(-e "$rootimg_dir/etc/zypp/repos.d/otherpkg.repo") {
	   system("rm -rf $rootimg_dir/etc/zypp/repos.d/otherpkg.repo");
       }
   }
   my $index=1;
   my $pass;
   foreach $pass (sort {$a <=> $b} (keys(%extra_hash))) {
     foreach (keys(%{$extra_hash{$pass}})) {
       if (($_ eq "PRE_REMOVE") || ($_ eq "POST_REMOVE") || ($_ eq "ENVLIST")) { next;} 
       my $whole_path="$srcdir_otherpkgs/$_";
       if (-r "$srcdir_otherpkgs/$_/repodata/repomd.xml") {
	   if($osver_host == 11) { 
	       system("zypper -R $rootimg_dir $non_interactive ar file:$srcdir_otherpkgs/$_  otherpkg$index");
	   }else {
	       system("zypper -R $rootimg_dir $non_interactive sa file:$srcdir_otherpkgs/$_");
	   }
       } else {
	   if($osver_host == 11) { 
	       system("zypper -R $rootimg_dir $non_interactive ar -t Plaindir file:$srcdir_otherpkgs/$_  otherpkg$index");
	   }else {
	       system("zypper -R $rootimg_dir $non_interactive sa -t Plaindir file:$srcdir_otherpkgs/$_");
	   }
       }
       $index++;

       my $pa=$extra_hash{$pass}{$_};
       $extrapkgnames{$pass} .= " " . join(' ', @$pa);
     }
   }

   #-- add custom repositories to the image  
   #TODO: should we add the support to otherpkgs for this? we have too many list files and it seems only SLES supports this
   # not sure, but it is convenient 
   my $repolist;
    $repolist = imgutils::get_profile_def_filename($osver, $profile, $arch, $customdir, "repolist");
    unless ($repolist) {
        $repolist = imgutils::get_profile_def_filename($osver, $profile, $arch, $pathtofiles, "repolist");
    }

   if ( -r "$repolist") {
     print "Reading custom repositories\n";
     open($repoconfig,"<","$repolist");
     while (<$repoconfig>) {
       chomp;
       next if /^\s*#/;
       my ($repotype,$repourl,$repoalias) = split m/\|/;
       if($osver_host == 11) {
         system("zypper -R $rootimg_dir $non_interactive ar $repourl $repoalias");
       }else {
         system("zypper -R $rootimg_dir $non_interactive sa $repourl $repoalias");
       }
     }
   }

   # Refresh the zypper cache in case there is still old data out there
   system("zypper -R $rootimg_dir $non_interactive  refresh");

   #my $yumcmd = "yum -y -c /tmp/genimage.$$.yum.conf --installroot=$rootimg_dir --disablerepo=* ";
   #$yumcmd .= "install ";
   #mkpath("$rootimg_dir/var/lib/yum");
   my $yumcmd;
   if($osver =~ /sles11/ && $osver_host == 11) {
       $yumcmd = "zypper -R $rootimg_dir $non_interactive install -l --no-recommends "; #add -l for SLES11
   }else {
       $yumcmd = "zypper -R $rootimg_dir $non_interactive install ";
   }

   #install packages from pkglist file
   my $pkgnames;
   unless ($imagename) {
       $pkglist = imgutils::get_profile_def_filename($osver, $profile, $arch, $customdir, "pkglist");
       unless ($pkglist) { $pkglist=imgutils::get_profile_def_filename($osver, $profile, $arch, $pathtofiles, "pkglist"); }
   }

   if ($pkglist) {
        $updates{'pkglist'} = $pkglist if ($tempfile);
    } else {
      print "Unable to find package list for $profile!";
      exit 1;
   }

   my %pkg_hash=imgutils::get_package_names($pkglist);
   my $index=1;
   foreach $pass (sort {$a <=> $b} (keys(%pkg_hash))) {
       $pkgnames = "";
       $group_pkgnames = "";
       foreach (keys(%{$pkg_hash{$pass}})) {
           if (($_ eq "PRE_REMOVE") || ($_ eq "POST_REMOVE") || ($_ eq "ENVLIST")) { next;} 
           my $pa=$pkg_hash{$pass}{$_};
           # replace the kernel package with the name has the specific version
           my @npa = ();
	   my @npa_group = ();
           foreach my $p (@$pa) {
             if ($p =~ /^kernel/ && $kernelver) {
               # get all files in $srcdir and $kerneldir
               my @alldirs = ("$srcdir", "$kerneldir");
               my @allrpms = ();
               foreach my $dir (@alldirs) {
                 my @files = `find $dir -name *.rpm`;
                 push @allrpms, @files;
               }
               my @kernelpkgs = ();
               if ($p =~ /^kernel$/) {
                 @kernelpkgs = ("kernel-default","kernel-default-base");
               } elsif ($p =~ /^kernel-ppc64$/) {
                 @kernelpkgs = ($p, $p."-base");
               } else {
                 @kernelpkgs = ($p);
               }
               foreach my $kern (@kernelpkgs) {
                 my @rpm = grep /$kern-$krpmver/, @allrpms;
                 if (!@rpm) {
                   print "Cannot find the kernel package with the versioin $krpmver.\n";
                   exit 1;
                 }
                 my $kernelname = "$kern-".$krpmver;
                 push @npa, $kernelname;
               }
             } else {
		 if($p =~ s/^@//)
		 {
		     push @npa_group, $p;
		 }
		 else
		 {
		     push @npa, $p;
		 }
             }
           }
           if (@npa) {
               $pkgnames .= " " . join(' ', @npa);
           }
           if (@npa_group) {
	       $group_pkgnames .= " " . join(' ', @npa_group);
           }
       }
        my $envlist;
        if(exists $pkg_hash{$pass}{ENVLIST}){
            $envlist = join(' ', @{$pkg_hash{$pass}{ENVLIST}});
        }
       if($pkgnames)
       {
           print "$envlist $yumcmd $pkgnames\n";
           $rc = system("$envlist $yumcmd $pkgnames");
	   $rc = $rc >> 8;
	   if (($rc) && ($rc != '104')) { 
	       print "zypper invocation failed with rc: $rc\n";
	       exit 1;
	   }
       }
       if($group_pkgnames)
       {
           print "$envlist $yumcmd -t pattern $group_pkgnames\n";
           $rc = system("$envlist $yumcmd -t pattern $group_pkgnames");
           $rc = $rc >> 8;
           if (($rc) && ($rc != '104')) { 
              print "zypper invocation failed with rc: $rc\n";
              exit 1;
           }
       }
   }

   foreach $pass (sort {$a <=> $b} (keys(%extra_hash))) {

       my $index=1;
       #remove the old repository for extra packages
       if ($osver_host == 11) {
           my $result=`zypper -R $rootimg_dir $non_interactive lr |grep otherpkg|cut -f2 -d '|'|tr "\n" " "`;
           if ($result =~ /\S/) {
               system("zypper -R $rootimg_dir $non_interactive rr $result");
           }
       } else {
           my $result=`zypper -R $rootimg_dir $non_interactive sl |grep otherpkg|cut -f2 -d '|'|tr "\n" " "`;
           if ($result =~ /\S/) {
               system("zypper -R $rootimg_dir $non_interactive sd $result");
           }
       }

       foreach (keys(%{$extra_hash{$pass}})) {
           if (($_ eq "PRE_REMOVE") || ($_ eq "POST_REMOVE") || ($_ eq "ENVLIST")) { next;}
           if (-r "$srcdir_otherpkgs/$_/repodata/repomd.xml") {
              if($osver_host == 11) {
                  system("zypper -R $rootimg_dir $non_interactive ar file:$srcdir_otherpkgs/$_  otherpkg$index");
               } else {
                    system("zypper -R $rootimg_dir $non_interactive sa file:$srcdir_otherpkgs/$_");
               }
           } else {
               if($osver_host == 11) {
                   system("zypper -R $rootimg_dir $non_interactive ar -t Plaindir file:$srcdir_otherpkgs/$_  otherpkg$index");
               }else {
                   system("zypper -R $rootimg_dir $non_interactive sa -t Plaindir file:$srcdir_otherpkgs/$_");
               }
           }
            $index++;
       }

       # Refresh the zypper cache in case there is still old data out there
       system("zypper -R $rootimg_dir $non_interactive  refresh");

       #remove the packages that are specified in the otherpkgs.list files with leading '-'
       my $envlist;
       if(exists $extra_hash{$pass}{ENVLIST}){
           $envlist = join(' ', @{$extra_hash{$pass}{ENVLIST}});
       }

       my $yumcmd_remove= "zypper -R $rootimg_dir $non_interactive remove ";
       if (exists ($extra_hash{$pass}{'PRE_REMOVE'})) {
           my $pa=$extra_hash{$pass}{'PRE_REMOVE'};
           my $rm_packges= join(' ', @$pa);
           if ($rm_packges) {
               print "$envlist $yumcmd_remove $rm_packges";
               $rc = system("$envlist $yumcmd_remove $rm_packges");
           }
       }
   

       #add extra packages in the list
       if ($extrapkgnames{$pass}) {
           print "$envlist $yumcmd $extrapkgnames{$pass}\n";
           $rc = system("$envlist $yumcmd $extrapkgnames{$pass}");
           $rc = $rc >> 8;
           if (($rc) && ($rc != '104')) { 
               print "zypper invocation failed with rc: $rc\n";
               exit 1;
           }
       }

       #remove the packages that are specified in the otherpkgs.list files with leading '--'
       if (exists ($extra_hash{$pass}{'POST_REMOVE'})) {
           my $pa=$extra_hash{$pass}{'POST_REMOVE'};
           my $rm_packges= join(' ', @$pa);
           if ($rm_packges) {
               print "$envlist $yumcmd_remove $rm_packges";
               $rc = system("$envlist $yumcmd_remove $rm_packges");
           }
       }
   }

   # run zypper update to update any installed rpms
   # needed when running genimage again after updating software in repositories
   my $yumcmd_update;
   if ($osver_host == 11) {
     $yumcmd_update = "zypper -R $rootimg_dir $non_interactive update ";
   } else {
     $yumcmd_update = "zypper -R $rootimg_dir $non_interactive update  ";
   }
   $rc = system("$yumcmd_update");
   # ignore any return code

   postscripts(); #run 'postscripts'
}
unlink "/tmp/genimage.$$.yum.conf";

# default to the first kernel found in the install image if nothing specified explicitly.
# A more accurate guess than whatever the image build server happens to be running 
# If specified, that takes precedence.
# If image has one, that is used
# If all else fails, resort to uname -r like this script did before
        
if ( -e "$rootimg_dir/boot/vmlinux" ) {
    $basekernelver = basename(readlink "$rootimg_dir/boot/vmlinux");
    if ($basekernelver eq "vmlinux") {
        $basekernelver = "";
    } else {
        $basekernelver =~ s/vmlinu.-//;
        $basekernelver =~ s/image-//;
    }
}

unless ($basekernelver) {
    my @KVERS = <$rootimg_dir/boot/vmlinu[xz]-*>;
      
    # The kernel name is different on s390x, e.g. image-2.6.32.9-0.5-default
    @KVERS = <$rootimg_dir/boot/image-*> if $arch eq "s390x";
    foreach (@KVERS) {
        s/vmlinu.-//;
        s/image-//;
    }
    unless (scalar @KVERS) {
        @KVERS = <$rootimg_dir/lib/modules/*>;
    }
    if (scalar @KVERS) {
        foreach my $kver (@KVERS) {
            unless ($kver =~ m/.gz$/) {
                $basekernelver = basename($kver);
                last;
            }
        }
    }

    @KVERS=<$rootimg_dir/lib/modules/*> unless (scalar @KVERS);
    $basekernelver = basename(pop @KVERS) if (scalar @KVERS);
    $basekernelver = `uname -r` unless ($basekernelver);
}

$kernelver = $basekernelver unless ($kernelver);
chomp $kernelver;
#$updates{kernelver} = $kernelver if ($tempfile);

# copy the kernel to $destdir
if ( -e "$rootimg_dir/boot/vmlinux-$kernelver") {
    copy("$rootimg_dir/boot/vmlinux-$kernelver", "$destdir/kernel");
} elsif ( -e "$rootimg_dir/boot/vmlinuz-$kernelver") {
    copy("$rootimg_dir/boot/vmlinuz-$kernelver", "$destdir/kernel");
} elsif ( -e "$rootimg_dir/boot/image-$kernelver") {
    copy("$rootimg_dir/boot/image-$kernelver", "$destdir/kernel");
} else {
    xdie "couldn't find the kernel file matched $kernelver in $rootimg_dir/boot !";
}

#-- run postinstall script
unless ($imagename) {
    $postinstall_filename= imgutils::get_profile_def_filename($osver, $profile, $arch, $customdir, "postinstall");
    unless ($postinstall_filename) {
        $postinstall_filename= imgutils::get_profile_def_filename($osver, $profile, $arch, $pathtofiles, "postinstall");
    }
} 

if ( $postinstall_filename ) {
    #print "postinstall_filename=$postinstall_filename\n";

    #For Mellonax IB script. In diskless image, the uname -r not returning the rootimg level, 
    #because the "uname -r" only returns the version of the kernel in use
    #create a temporary uname script. for every flag except for -r, it should just call the real 
    #uname with the same flags and return that info.
    if(!( -e "$rootimg_dir/bin/orig_uname")) {
        system("mv $rootimg_dir/bin/uname $rootimg_dir/bin/orig_uname");
    }
    my $tmpuname;
    open($tmpuname,">","$rootimg_dir/bin/uname");
    print $tmpuname <<EOS_UNAME;
#!/bin/sh

if [[ \$\# -eq 1 && \$1 == "-r" ]]; then
    echo $kernelver
    exit 0
fi

res=`/bin/orig_uname \$\*`
echo \$res

EOS_UNAME

    close($tmpuname);
    system("chmod +x $rootimg_dir/bin/uname");

    $updates{'postinstall'} = $postinstall_filename if ($tempfile);

    foreach my $postinstall ( split /,/, $postinstall_filename ) {
        if ( !-x $postinstall ) {
            print "postinstall script $postinstall is not executable\n";
            exit 1;
        }
        my $rc = system($postinstall, $rootimg_dir,$osver,$arch,$profile);
        if($rc) {
            print "postinstall script $postinstall failed\n";
            exit 1;
        }
    }


    # restore the orig uname
    system("mv $rootimg_dir/bin/orig_uname $rootimg_dir/bin/uname");

}

# output the changed the attributes so that it can be save into db by the caller.
# all the information has been gathered
# now, update the linuximage and osimage tables
# TODO: do statelite and stateless share the same attributes? currently, I will update both of them
#BEGIN: PLEASE DO NOT CHANGE THE FOLLOWING CODE, genimage PLUGIN NEEDS TO PARSE THR OUTPUT
if ($tempfile) {
    open(FILE, ">>$tempfile");
    if ($imagename) {
	if (keys(%updates) > 0) {
	    print FILE "The output for table updates starts here\n";
	    print FILE "table::linuximage\n";
	    print FILE "imagename::$imagename\n";
	    my @a=%updates;
	    print FILE join('::',@a) . "\n";
	    print FILE "The output for table updates ends here\n";
	}
    } else {
	$updates_os{'profile'} = $profile;
	$updates_os{'imagetype'} = 'linux';
	$updates_os{'provmethod'} = 'netboot';
	$updates_os{'osname'} = 'Linux';
	$updates_os{'osvers'} = $osver;
	$updates_os{'osdistro'} = 'sles'; # not used currently
	$updates_os{'osarch'} = $arch;
	# update the imagename for stateless 
	print FILE "The output for table updates starts here\n";
	print FILE "table::osimage\n";
	print FILE "imagename::$osver-$arch-netboot-$profile\n";
	my @a=%updates_os;
	print FILE join('::',@a) . "\n";
	print FILE "The output for table updates ends here\n";
	
	print FILE "The output for table updates starts here\n";
	print FILE "table::linuximage\n";
	print FILE "imagename::$osver-$arch-netboot-$profile\n";
	my @a=%updates;
	print FILE join('::',@a) . "\n";
	print FILE "The output for table updates ends here\n";
	
	# update the imagename for statelite   
	$updates_os{'provmethod'} = 'statelite';
	print FILE "The output for table updates starts here\n";
	print FILE "table::osimage\n";
	print FILE "imagename::$osver-$arch-statelite-$profile\n";
	my @a=%updates_os;
	print FILE join('::',@a) . "\n";
	print FILE "The output for table updates ends here\n";
	
	print FILE "The output for table updates starts here\n";
	print FILE "table::linuximage\n";
	print FILE "imagename::$osver-$arch-statelite-$profile\n";
	my @a=%updates;
	print FILE join('::',@a) . "\n";
	print FILE "The output for table updates ends here\n";
    }
    close FILE;
}
#END



mkpath "$rootimg_dir/.statelite"; # create place for NFS mounts;
mkpath "$rootimg_dir/.sllocal/localmnt";  # create place for localdisk mount
mkpath "$rootimg_dir/.sllocal/log";  # create place for localdisk log

mkpath "$rootimg_dir/root/.ssh"; # create place for NFS mounts for ssh; #TODO is necessary?

# this script will get the directories;
# TODO: it seems it is re-copied in liteimg.pm
unless( -r "$pathtofiles/../add-on/statelite/rc.statelite") {
    print "Can't find $pathtofiles/../add-on/statelite/rc.statelite!\n";
    exit;
}
system("cp $pathtofiles/../add-on/statelite/rc.statelite $rootimg_dir/etc/init.d/statelite");
system("cp $pathtofiles/../add-on/statelite/rc.localdisk $rootimg_dir/etc/init.d/localdisk");

# the dhcp client information stores in the directory "/var/lib/dhcpcd/"
unless(-l "$rootimg_dir/var/lib/dhcpcd") {
    mkpath "$rootimg_dir/var/lib/dhcpcd/";
    system("touch $rootimg_dir/var/lib/dhcpcd/dhcpcd-$prinic.info");
}
# which is different from the Redhat family

# some rpms mounts the imageroot/proc on the /proc, need to release it, 
# otherwise got kernal panic when installing 
# sometimes, the proc fs is not mounted, so one warning/error message will display,
# and I add one check point here.
my $MFD;
open MFD, "/proc/mounts";
my @lines = <MFD>;
close MFD;

my $ret = grep m{$rootimg_dir/proc}, @lines;
if($ret > 0) {
    system("umount -l $rootimg_dir/proc");
}

# Load driver update disk, and copy them to the root image
my @dd_drivers = &load_dd();

# Push the drivers into the @ndrivers base on the order
my @new_order = ();
foreach my $dd (@dd_drivers) {
    unless (grep { $_ eq $dd} @ndrivers) {
        push @new_order, $dd;
    }
    print "Added driver $dd from driver update disk or driver rpm\n";
}

foreach my $driver (@ndrivers) {
    print "Added driver $driver from root image\n";
}

if (@new_order) {
    @ndrivers = (@new_order, @ndrivers);
}

# add drivers for local disk support
push @ndrivers, ("ext3.ko", "ext4.ko", "virtio_pci.ko", "virtio_blk.ko", "ata_piix.ko", "libata.ko", "scsi_mod.ko", "ibmvscsi.ko", "ibmvscsic.ko", "megaraid_sas.ko", "pcieport.ko", "sd_mod.ko");

open($moddeps,"<","$rootimg_dir/lib/modules/$kernelver/modules.dep");
my @moddeps = <$moddeps>;
my @checkdeps = @ndrivers;
while (scalar @checkdeps) {
    my $driver = pop @checkdeps;
    my @lines = grep /\/$driver:/,@moddeps;
    foreach (@lines) {
        chomp;
        s/.*://;
        s/^\s*//;
        my @deps = split /\s+/,$_;
        my $dep;
        foreach $dep (@deps) {
            $dep =~ s/.*\///;
            unless (grep { $_ eq $dep } @ndrivers) { #only add if not added
                print "Added $dep as an autodetected depedency\n";
            }
            unshift (@checkdeps,$dep); #recursively check dependencies
            unshift (@ndrivers,$dep);
        }
    }
}
close($moddeps);

#remove the duplicated drivers
my @fulldrivers;
foreach my $dn (@ndrivers) {
    unless (grep {$_ eq $dn} @fulldrivers) {
        push @fulldrivers, $dn;
    }
}
@ndrivers = @fulldrivers;

# before mkinitrd, run depmod to generate the modules.dep
system("chroot $rootimg_dir depmod $kernelver");

my @drivers; # backup  of @ndrivers
push @drivers, @ndrivers;
mkinitrd("statelite");
@ndrivers=();
push @ndrivers, @drivers;
mkinitrd("stateless");


sub getlibs {
    my $file = shift;
    my $liblist = `chroot $rootimg_dir ldd $file`;
    if ($liblist =~ /not a dynamic executable/) {
        return;
    }
    my @libs = split/\n/,$liblist;
    my @return;
    foreach (@libs) {
        unless (/=>/) {
            (my $wjnk, my $lib,my $jnk) = split /\s+/,$_,3;
            $lib =~ s/^\///;
            $libhash{$lib}=1;
            next;
        }
        (my $temp1,my $temp2) = split />/,$_,2;
        (my $whitespace,$temp1,$temp2) = split /\s+/,$temp2,4;
        unless ($temp1 =~ /\//) {
            next;
        }
        $temp1 =~ s/^\///;
        $libhash{$temp1}=1;
    }
}

sub mkinitrd {
    my ($mode) = @_; # statelite or stateless

    if ($mode eq "statelite") {

        # additional modules needed on s390x
        push @ndrivers, qw{qdio.ko ccwgroup.ko qeth.ko qeth_l2.ko qeth_l3.ko} if ($arch eq "s390x");
        
        # for nfs
        my @modlist = qw{sunrpc.ko lockd.ko nfs_acl.ko fscache.ko auth_rpcgss.ko exportfs.ko nfsd.ko nfs.ko};
        unshift(@ndrivers, @modlist);
     }

    mkpath("/tmp/xcatinitrd.$$/bin");
    symlink("bin","/tmp/xcatinitrd.$$/sbin");
    mkpath("/tmp/xcatinitrd.$$/usr/bin");
    mkpath("/tmp/xcatinitrd.$$/usr/sbin");
    mkpath("/tmp/xcatinitrd.$$/usr/lib");
    mkpath("/tmp/xcatinitrd.$$/usr/lib64");
    mkpath("/tmp/xcatinitrd.$$/lib/firmware");
    mkpath("/tmp/xcatinitrd.$$/tmp");
    mkpath("/tmp/xcatinitrd.$$/var/run");
    mkpath("/tmp/xcatinitrd.$$/lib64/firmware");
    mkpath("/tmp/xcatinitrd.$$/lib/power6");#SLES10
    mkpath("/tmp/xcatinitrd.$$/lib/power7");#SLES10
    mkpath("/tmp/xcatinitrd.$$/lib/mkinitrd/bin");
    mkpath("/tmp/xcatinitrd.$$/proc");
    mkpath("/tmp/xcatinitrd.$$/sys");
    mkpath("/tmp/xcatinitrd.$$/dev/mapper");
    mkpath("/tmp/xcatinitrd.$$/sysroot");
    mkpath("/tmp/xcatinitrd.$$/etc/ld.so.conf.d");
    mkpath("/tmp/xcatinitrd.$$/var/lib/dhcpcd");
    my $inifile;
    open($inifile,">","/tmp/xcatinitrd.$$/init");
    print $inifile "#!/bin/bash\n";

# copied from genimage for rh
# add some functions
    print $inifile <<EOS1;
NEWROOT="/sysroot"
SHELL="/bin/sh"
RWDIR=".statelite"

# Define some colors
RESET="\033[0m"
RED="\033[31m"
CYAN="\033[36m"
YELLOW="\033[33m\033[1m"
GREEN="\033[32m"
PINK="\033[35m\033[1m"
MAGENTA="\033[35m"
BROWN="\033[33m"
NORMAL=\$RESET

# This function is used to mount files/directories from the .statelite directory 
#  over the root directory.
# This function stolen from redhat
shell() {
        echo ''
        echo -e "\$YELLOW Entering rescue/debug init shell."
        echo -e " Exit shell to continue booting.\$RESET"
        \$SHELL
}

fancydisplay () {
        clear
        echo -e "\$CYAN"
echo '
             ..                                               :iiii,
           :tLL;                                             .,:...,.
          .j;:tLt.   :.                               .;j:   ij::::;.
        :tt;:::,ii:.jEEGi                           :tDEEG:.ti,::::;t:
       .,,,,,,,,,,,tLEEEEj:                        tDEEEEDtj;,,,::::::
        .:,,::::::,;fDEEEEEL,.                .,ijDEDDDEEGt,,,,:,ijj;
          ....   ..:;jDDLGDEEEGGGfjjjjjjfffLGDEEDEEDLjfGDt,:..
                     .iftffGDLLDEEEDDDEEDDDDEDEEGLfLjjtti:
                       ,fii;jGDGffLjifLGLjtfffffGDEDGfji
                        ;DEEGffDDDjiii;;ii;,tGDEGjfEEEEf.
                       ,GEGGftiGEEEDt:,;,;;LEEDGjLEEEEEEG
                      ;DEDGjtjfitjGGjfDGj;jLLiitfGDEGjEEDj
                      fGjjtfLfji;itjfGDjLDfjjjji;tGGLDEEDj
                      fEDGffjti;ittjjjjtjjjjt:,,iiGGGGjtf.
                      :fGGLfLLfLGf;i;ijffj,,tjLGDDGLfjtf,
                    :;tLfjiiffLGDDDGLGEEEEjfGDDGGLfjfff:
             .. ,;tLLLLLL,;tijfLGGGjfDEEEEDLLGGGLLLjtjLLfi,.
         .jffLLLLGGLfjj;:  :,;ijLGLfjGEDDEGtfGGLfjj:.,jjLGGLti;,,;fj,
         ,fGGGGGGLj,.          ;jGGGGLLjffftjLj;..     .,tfGGGGGGGGGGi
          ,jGDDDj,.              :tLGLGGLGDLjt,           :iLGGDDDDGLif
          ,LDDDL,                 .;LDDDDGfff,              ,;iGDDj;,..
          ;fGGGf,                    ,;;;;,:                 tf;jL,
           ;.:::,               Powered by xCAT               ,j.:;
'
        echo -e "\$RESET"
        echo -e "\$YELLOW"
echo '
                            _________     ________________
                     ___  __\\_   ___ \\   /  _  \\__    ___/
                     \\  \\/  /    \\  \\/  /  /_\\  \\|    |   
                      >    <\\     \\____/    |    \\    |   
                     /__/\\_ \\\\______  /\\____|__  /____|   
                           \\/       \\/         \\/         
'
        echo -e "\$RESET"
}


EOS1

   print $inifile "mount -t proc /proc /proc\n";
   print $inifile "mount -t sysfs /sys /sys\n";
   print $inifile "mount -o mode=0755 -t tmpfs /dev /dev\n";
   print $inifile "mkdir /dev/pts\n";
   print $inifile "mount -t devpts -o gid=5,mode=620 /dev/pts /dev/pts\n";
   print $inifile "mkdir /dev/shm\n";
   print $inifile "mkdir /dev/mapper\n";

   print $inifile "mknod /dev/random c 1 8\n";
   print $inifile "mknod /dev/urandom c 1 9\n";
   print $inifile "mknod /dev/null c 1 3\n";
   print $inifile "mknod /dev/zero c 1 5\n";
   print $inifile "mknod /dev/systty c 4 0\n";
   print $inifile "mknod /dev/tty c 5 0\n";
   print $inifile "mknod /dev/console c 5 1\n";
   print $inifile "mknod /dev/ptmx c 5 2\n";
   print $inifile "mknod /dev/rtc c 10 135\n";
   print $inifile "mknod /dev/tty0 c 4 0\n";
   print $inifile "mknod /dev/tty1 c 4 1\n";
   print $inifile "mknod /dev/tty2 c 4 2\n";
   print $inifile "mknod /dev/tty3 c 4 3\n";
   print $inifile "mknod /dev/tty4 c 4 4\n";
   print $inifile "mknod /dev/tty5 c 4 5\n";
   print $inifile "mknod /dev/tty6 c 4 6\n";
   print $inifile "mknod /dev/tty7 c 4 7\n";
   print $inifile "mknod /dev/tty8 c 4 8\n";
   print $inifile "mknod /dev/tty9 c 4 9\n";
   print $inifile "mknod /dev/tty10 c 4 10\n";
   print $inifile "mknod /dev/tty11 c 4 11\n";
   print $inifile "mknod /dev/tty12 c 4 12\n";
   print $inifile "mknod /dev/ttyS0 c 4 64\n";
   print $inifile "mknod /dev/ttyS1 c 4 65\n";
   print $inifile "mknod /dev/ttyS2 c 4 66\n";
   print $inifile "mknod /dev/ttyS3 c 4 67\n";

    # Install modules before starting udev 
    # because networking modules (qeth/qeth_l2/qeth_l3) are needed
    foreach (@ndrivers) {
        print $inifile "insmod /lib/$_\n";
    }

    # Start udev
	print $inifile <<EOMS;

PATH="\$PATH:/usr/sbin:/sbin"
export PATH

# Start udev to find devices attached to node
# This script can be found in /lib/mkinitrd
echo "Creating device nodes with udev"
/sbin/udevd --daemon
if [ -f "/sbin/udevadm" ]
then
    /sbin/udevadm trigger
    /sbin/udevadm settle --timeout=10
fi
EOMS
    
    if($mode eq "statelite") {
        print $inifile "echo debug: before netstart\n";
        print $inifile "# check and see if debug is specified on command line\n";
        print $inifile "grep '\(debug\)' /proc/cmdline > /dev/null && export DEBUG=1\n";
    }

   print $inifile <<EOMS;
# check the kernel parameters firstly
# if one parameter for the booting device is here, it will be used
PRINIC=$prinic
NODESTATUS='y'
XCATMNTOPTS='nolock,tcp'
for i in `cat /proc/cmdline`; do
    KEY=`echo \$i |awk -F= '{print \$1}'`
    if [ "\$KEY" == 'netdev' ]; then
        NETDEV=`echo \$i |awk -F= '{print \$2}'`
    elif [ "\$KEY" == 'BOOTIF' ]; then
        VALUE=`echo \$i |awk -F= '{print \$2}'|sed -e s/^01-// -e s/-/:/g`
        BOOTIF=`ifconfig -a|grep -i "hwaddr \$VALUE"|awk '{print \$1}'`
    elif [ "\$KEY" == 'XCAT' ]; then
        VALUE=`echo \$i |awk -F= '{print \$2}'`
        # format: XCAT=xcatmaster:xcatdport
        XCATSERVER=\$VALUE
    elif [ "\$KEY" == 'MNTOPTS' ]; then
        VALUE=`echo \$i |awk -F\\' '{print \$2}'`
        # format: MNTOPTS='nolock,time=800'
        XCATMNTOPTS=\$VALUE

    fi


    if [ \$i == 'nonodestatus' ]; then
       NODESTATUS='n'
    fi
done

if [ -z "\$IFACE" ]; then
    if [ ! -z "\$NETDEV" ]; then
        IFACE=\$NETDEV
    elif [ ! -z "\$BOOTIF" ]; then
        IFACE=\$BOOTIF
    elif [ ! -z "\$PRINIC" ]; then
        IFACE=\$PRINIC
    else
        echo "\${RED}Couldn't find the proper booting device, switch to shell...\${RESET}"
        shell
        exit
    fi
fi

export IFACE=\$IFACE

/usr/bin/touch /var/lib/dhcpcd/dhcpcd-\$IFACE.info

netstart \$IFACE
while ! ifconfig | grep inet; do
    echo -e "\${RED}Failed to acquire address, retrying \${RESET}"
    sleep 1
    netstart \$IFACE
done
# Add a fake interface configuration file for the boot interface to skip the
# ifdown of the interface during the reboot/shutdown to skip the fs broken of
# nfs based file system
echo "STARTMODE=nfsroot" > /tmp/ifcfg-\$IFACE

ip addr add dev lo 127.0.0.1/8
ip link set lo up


XCATMASTER=`echo \$XCATSERVER|awk -F: '{print \$1}'`

if [ -z \$XCATIPORT ]; then
     XCATIPORT="3002"
fi

if [ \$NODESTATUS != 'n' ]; then
    /tmp/updateflag \$XCATMASTER \$XCATIPORT "installstatus netbooting"
fi

cd /
for i in `cat /proc/cmdline`; do
   KEY=`echo \$i |awk -F= '{print \$1}'`
   if [ "\$KEY" == 'imgurl' ]; then
      VALUE=`echo \$i |awk -F= '{print \$2}'`
      if [ "http" == "`echo \$VALUE|awk -F: '{print \$1}'`" ]; then
        #NOTE needs FT retry code to scale
        #NOTE: should prob have max count
        FILENAME=`echo \$VALUE|awk -F/ '{print \$NF}'`
        while [ ! -r "\$FILENAME" ]; do
          echo Getting \$VALUE...
          if ! wget \$VALUE; then
            sleep 5 #should be random, exponential for scale
            rm -f \$FILENAME
          fi
        done
      fi
   elif [[ "\$KEY" == NFSROOT ]]; then # for NFSROOT
        NFSROOT=1
        VALUE=`echo \$i |awk -F= '{print \$2}'`
        SERVER=`echo \$VALUE|awk -F: '{print \$1}'`
        ROOTDIR=`echo \$VALUE|awk -F/ '{for(i=2;i<=NF;i++) printf "/%s",\$i}'`
   elif [ "\$KEY" == 'STATEMNT' ]; then
        STATELITE=1
        VALUE=`echo \$i |awk -F= '{print \$2}'`
        # VALUE may be null
        if [ ! -z \$VALUE ]; then
            SNAPSHOTSERVER=`echo \$VALUE|awk -F: '{print \$1}'`
            SNAPSHOTROOT=`echo \$VALUE|awk -F/ '{for(i=2;i<=NF;i++) printf "/%s",\$i}'`
            # may be that there is not server and just a directory.
            if [ -z \$SNAPSHOTROOT ]; then
                SNAPSHOTROOT=\$SNAPSHOTSERVER
                SNAPSHOTSERVER=
            fi
        fi
    fi
done

# show xCAT logo
fancydisplay

# Statelite code is here
if [ "\$STATELITE" = "1" ]; then
    echo Setting up Statelite
    mknod /dev/loop0 b 7 0
    mkdir -p \$NEWROOT
    MAXTRIES=15
    ITER=0
    ME=`hostname`
    if [ "\$NFSROOT" = "1" ]; then
        while ! mount.nfs \${SERVER}:\${ROOTDIR}/rootimg \$NEWROOT -r -n -o nolock,rsize=32768,tcp,nfsvers=3,timeo=14; do
            ITER=\$(expr \$ITER + 1)
            if [ "\$ITER" = "\$MAXTRIES" ]; then
                echo "You're dead. rpower \$ME boot to play again."
                echo "Possible problems:
1.  This initrd wan't created for the statelite node? 
2.  IS DNS set up? Maybe that's why I can't mount \${SERVER}.
3.  The nfs modules aren't set right in this initial ramdisk?"
                shell
                exit
            fi
            echo -e "\${RED}Couldn't mount \$SERVER:\$ROOTDIR on \$NEWROOT \$RESET"
            RS=\$(expr \$RANDOM % 30)
            echo -e "Trying again in \$RS seconds"
            sleep \$RS
        done
    else
        # for statelite mode on top of the ramdisk
EOMS

    print $inifile "if [ -r /rootimg-statelite.gz ]; then \n";
    print $inifile "echo Setting up RAM-root tmpfs.\n";
    if ($rootlimit) {
        print $inifile "    mount -o size=$rootlimit,mode=755 -t tmpfs rootfs \$NEWROOT \n";
    } else {
        print $inifile "    mount -o mode=755 -t tmpfs rootfs \$NEWROOT \n";
    }

    print $inifile <<EOMS;
        cd \$NEWROOT
        echo -n "Extracting root file system:"
        if [ -x /bin/cpio ]; then
            gzip -cd /rootimg-statelite.gz | /bin/cpio -idum
        else
            gzip -cd /rootimg-statelite.gz | cpio -idum
        fi
        echo "Done"
    else
        echo -e "\${RED} Couldn't find rootimg-statelite.gz for statelite semantics on top of ramdisk \${RESET}"
        shell
        exit
    fi
fi
# now we need to mount the rest of the system.  This is the read/write portions
#echo "Mounting Snapshot directories"
    if [ ! -e "\$NEWROOT/\$RWDIR" ]
    then
        echo ""
        echo -e "\${RED}Hmmm... this NFS root directory doesn't have a /\$RWDIR directory for me to mount a rw filesystem.  You'd better create it... \${NORMAL}"
        echo "."
        shell
    fi

    while [ ! -e "\$NEWROOT/etc/init.d/statelite" ]
    do
        echo ""
        echo -e "\${RED}Hmmm... \$NEWROOT/etc/init.d/statelite doesn't exist.  Perhaps you didn't create this image with the -m statelite mode"
        echo ""
        shell
    done
    grep '\\(shell\\)' /proc/cmdline >/dev/null && shell
    mount -t tmpfs rw -o mode=$permission \$NEWROOT/\$RWDIR
    mkdir -p \$NEWROOT/\$RWDIR/tmpfs

    #mount the /root/.ssh, it needs more strict permission in order for ssh work
    #if [ ! -e "\$NEWROOT/root/.ssh" ]
    #then
    #    mkdir -p \$NEWROOT/root/.ssh
    #fi
    #mount -t tmpfs -o mode=755 ssh \$NEWROOT/root/.ssh

    # mount the SNAPSHOT directory here for persistent use.
    if [ ! -z \$SNAPSHOTSERVER ]
    then
        mkdir -p \$NEWROOT/\$RWDIR/persistent
        MAXTRIES=5
        ITER=0
        while ! mount \$SNAPSHOTSERVER:\$SNAPSHOTROOT  \$NEWROOT/\$RWDIR/persistent -o nolock,\$XCATMNTOPTS
        do
            ITER=\$(expr \$ITER + 1)
            if [ "\$ITER" == "\$MAXTRIES" ]
            then
                echo "You're dead.  rpower \$ME boot to play again."
                echo "Possible problems:
1.  \$SNAPSHOTSERVER is not exporting \$SNAPSHOTROOT ?
2.  Is DNS set up?  Maybe that's why I can't mount \$SNAPSHOTSERVER."
                shell
                exit
            fi
            echo -e "\${RED}Hmmm... Can't mount \$SNAPSHOTSERVER:\$SNAPSHOTROOT. \${NORMAL} \$XCATMNTOPTS"
            RS=`expr \$RANDOM % 20`
            echo -e "Trying again in \$RS seconds"
            sleep \$RS 
        done
    fi

    grep '\\(shell\\)' /proc/cmdline >/dev/null && shell

    # have to preserve the initial DHCP request. So we  link it.
    # SLES uses different file to store DHCP info
    if [ ! -d \$NEWROOT/\$RWDIR/tmpfs/var/lib/dhcpcd ]
    then
        mkdir -p \$NEWROOT/\$RWDIR/tmpfs/var/lib/dhcpcd
    fi
    cp -fp /var/lib/dhcpcd/dhcpcd-\$IFACE.info \${NEWROOT}/\${RWDIR}/tmpfs/var/lib/dhcpcd/dhcpcd-\$IFACE.info
    
    [ -e /etc/ntp.conf ] && mkdir -p \$NEWROOT/\$RWDIR/tmpfs/etc && cp /etc/ntp.conf \$NEWROOT/\$RWDIR/tmpfs/etc/

    [ -e /etc/resolv.conf ] && mkdir -p \$NEWROOT/\$RWDIR/tmpfs/etc && cp /etc/resolv.conf \$NEWROOT/\$RWDIR/tmpfs/etc/

    # now that everything is mounted, lets do this
    # hmmm, apparently I'm checking this twice... so I'd better
    # be really sure the file is there.
    while [ ! -e \$NEWROOT/etc/init.d/statelite ]
    do
        echo "\$NEWROOT/etc/init.d/statelite does not exist in image!"
        shell
    done 

    # try to configure the local disk
    \$NEWROOT/etc/init.d/localdisk

    # do all the mounts:
    \$NEWROOT/etc/init.d/statelite
EOMS

    # udevd needed by s390x for networking
    # but for other type of machine, udevd will affect the start of devices which detected
    #  after the chroot, so kill it before the switching root 
    if ($arch ne "s390x") {
       print $inifile "\n    killall -9 udevd\n";
    }

    print $inifile <<EOMS;    
    # give the debug shell just before we go if specified!
    grep '\(shell\)' /proc/cmdline > /dev/null && shell
    
    echo 0x100 > /proc/sys/kernel/real-root-dev
    export keep_old_ip=yes
    export fastboot=yes
    export READONLY=yes
    grep '\\(shell\\)' /proc/cmdline >/dev/null && shell
    mount -n --bind /dev /sysroot/dev
    umount /sys
    umount /proc
    
    # sles use the standard utility to chroot
    if ! exec /usr/bin/chroot \$NEWROOT /sbin/init
    then
        echo ""
        echo -e "\${RED}Couldn't chroot.  Something must be wrong with NFS root image.\${RESET}"
        shell
    fi
    exit
fi
# end NFSROOT/Statelite code

if [ -r /rootimg.sfs ]; then
  echo Setting up squashfs with ram overlay.
  mknod /dev/loop0 b 7 0
  mkdir -p /ro
  mkdir -p /rw
  mount -t squashfs /rootimg.sfs /ro
  mount -t tmpfs rw /rw
  mount -t aufs -o dirs=/rw:/ro mergedroot /sysroot
  mkdir -p /sysroot/ro
  mkdir -p /sysroot/rw
  mount --move /ro /sysroot/ro
  mount --move /rw /sysroot/rw
EOMS
   print $inifile "elif [ -r /rootimg.gz ]; then\n";
   print $inifile "echo Setting up RAM-root tmpfs.\n";
   if ($rootlimit) {
      print $inifile "  mount -o size=$rootlimit,mode=755 -t tmpfs rootfs \$NEWROOT\n";
   } else {
      print $inifile "  mount -o  mode=755 -t tmpfs rootfs \$NEWROOT\n";
   }
   print $inifile "  cd /sysroot\n";
   print $inifile "  echo -n \"Extracting root filesystem:\"\n";
   print $inifile "  if [ -x /bin/cpio ]; then\n";
   print $inifile "  zcat /rootimg.gz |/bin/cpio -idum\n";
   print $inifile "  else\n";
   print $inifile "  zcat /rootimg.gz |cpio -idum\n";
   print $inifile "  fi\n";
   print $inifile "  echo Done\n";
   print $inifile "else\n";
   print $inifile "  echo -n Failed to download image, panicing in 5...\n";
   print $inifile "  for i in 4 3 2 1 0; do\n";
   print $inifile "    /bin/sleep 1\n";
   print $inifile "    echo -n \$i...\n";
   print $inifile "  done\n";
   print $inifile "  echo\n";
   print $inifile <<EOMS;
echo "You're dead.  rpower nodename reset to play again.

* Did you packimage with -m cpio or -m squashfs?
* If using -m squashfs did you include aufs.ko with geninitrd?
  e.g.:  -n tg3,squashfs,aufs,loop
"
sleep 5
EOMS
   print $inifile "  exit\n";
   print $inifile "fi\n";

   # udevd needed by s390x for networking
   # but for other type of machine, udevd will affect the start of devices which detected
   #  after the chroot, so kill it before the switching root
   if ($arch ne "s390x") {
      print $inifile "killall -9 udevd\n";
   }

   print $inifile "cd /\n";
   print $inifile "\$NEWROOT/etc/init.d/localdisk\n"; # to run the localdisk
   print $inifile "mkdir \$NEWROOT/var/lib/dhcpcd/\n";	#neccessary for SLES11, not sure for SLES10
   print $inifile "cp /var/lib/dhcpcd/* \$NEWROOT/var/lib/dhcpcd/\n";
   print $inifile "cp /etc/resolv.conf \$NEWROOT/etc/\n";
   print $inifile "cp /etc/HOSTNAME \$NEWROOT/etc/\n";
   print $inifile "mknod \$NEWROOT/dev/console c 5 1\n";
   print $inifile "exec /lib/mkinitrd/bin/run-init -c /dev/console \$NEWROOT /sbin/init\n";
   close($inifile);
   open($inifile,">"."/tmp/xcatinitrd.$$/bin/netstart");
   print $inifile "#!/bin/bash \n";
   if ($osver_host == 10) {
      print $inifile "dhcpcd \${1}\n";
   } else { # for sles11 or higher
      # -p is used to keep the network connection during the shutdown. Used for nfs-based statelite shutdown
      print $inifile "dhcpcd \${1} -p\n";
   }

   #-- Bring other NICs up in /bin/netstart in initrd for NIC failover
   foreach (split /,/,$othernics) {
      if (/^$/) { next; }
      print $inifile "dhcpcd $_\n";
   }

   print $inifile <<END;
cat /var/lib/dhcpcd/*info | grep HOSTNAME | uniq | awk -F= '{print \$2}'| sed \"s/'//g\" >> /etc/HOSTNAME
END

   close($inifile);

   #if "nonodestatus" specified,do not update the nodestatus 
   system("mkdir -p /tmp/xcatinitrd.$$/tmp/");
   open($inifile, ">","/tmp/xcatinitrd.$$/tmp/updateflag");

   print $inifile <<EOMS;
#!/usr/bin/awk -f
BEGIN {

        xcatdhost = ARGV[1]
        xcatiport = ARGV[2]


        ns = "/inet/tcp/0/" xcatdhost "/" xcatiport
        print "xCAT_xcatd" |& ns

        while(1) {
                ns |& getline

                if(\$0 == "ready")
                        print ARGV[3] |& ns
                if(\$0 == "done")
                        break
        }

        close(ns)

        exit 0
}

EOMS
      
   close($inifile);
   chmod(0755,"/tmp/xcatinitrd.$$/init");
   chmod(0755,"/tmp/xcatinitrd.$$/bin/netstart");
   chmod(0755,"/tmp/xcatinitrd.$$/tmp/updateflag");

   @filestoadd=();
   foreach (@ndrivers) {
     if (-f "$customdir/$_") {
         push @filestoadd,[$_,"lib/$_"];
     } elsif (-f "$pathtofiles/$_") {
         push @filestoadd,[$_,"lib/$_"];
     }
   }
    if($mode eq "statelite") {
        foreach ("sbin/ifconfig", "usr/bin/clear","usr/bin/touch","bin/hostname","usr/bin/egrep","bin/ln","bin/ls","usr/bin/dirname","usr/bin/expr","usr/bin/chroot","usr/bin/grep","bin/cpio","bin/sleep","bin/mount","bin/umount","sbin/dhcpcd","bin/bash","sbin/insmod","bin/mkdir","bin/mknod","sbin/ip","bin/cat","usr/bin/awk","usr/bin/wget","bin/cp","usr/bin/cpio","usr/bin/zcat","usr/bin/gzip","lib/mkinitrd/bin/run-init","usr/bin/uniq","usr/bin/sed","usr/bin/wc", "bin/sed","sbin/udevd", "usr/bin/readlink", "usr/sbin/parted", "sbin/mke2fs", "sbin/mkswap", "sbin/swapon", "bin/chmod", "usr/bin/bc") {
            getlibs($_); 
            push @filestoadd,$_;
        } 
        if($osver_host == 11) {
            foreach ("sbin/mount.nfs", "sbin/umount.nfs", "sbin/udevadm") {
                getlibs($_);
                push @filestoadd,$_;
            }
        }
        
    }else {
        foreach ("sbin/ifconfig","usr/bin/clear","usr/bin/touch","usr/bin/grep","usr/bin/egrep","bin/cpio","bin/sleep","bin/mount","sbin/dhcpcd","bin/bash","sbin/insmod","bin/mkdir","bin/mknod","sbin/ip","bin/cat","usr/bin/awk","usr/bin/wget","bin/cp","usr/bin/cpio","usr/bin/zcat","usr/bin/gzip","lib/mkinitrd/bin/run-init","usr/bin/uniq","usr/bin/sed","sbin/udevd", "usr/bin/readlink", "usr/bin/expr", "usr/sbin/parted", "sbin/mke2fs", "sbin/mkswap", "sbin/swapon", "bin/chmod", "usr/bin/bc") {
            getlibs($_); 
            push @filestoadd,$_;
        }
        if($osver_host == 11) {
            getlibs("sbin/udevadm");
            push @filestoadd,"sbin/udevadm";
        }
    }

   if ($arch =~ /64/) {
      push @filestoadd,"lib64/libnss_dns.so.2";
      push @filestoadd,"lib64/libnss_files.so.2";
   }
   else {
      push @filestoadd,"lib/libnss_dns.so.2";
      push @filestoadd,"lib/libnss_files.so.2";
   }

    # cross-platfrom support on power6&7 etc
    # ldd can't handle such one scenario: mn is power6, the target platform is power7
   if ($arch =~ /ppc64/) {
      system("cp -a -r $rootimg_dir/lib64/* /tmp/xcatinitrd.$$/lib64/");
   }


   push @filestoadd,keys %libhash;

   find(\&isnetdriver, <$rootimg_dir/lib/modules/$kernelver/*>);
   my $pathonrootimage = "$rootimg_dir/tmpfiles";
   my $pathinrootimage = "/tmpfiles";
   mkpath($pathonrootimage);
   foreach (@filestoadd) {
      if (ref($_)) {
         #print "$_->[0], $_->[1]\n";
         my $srcfile = $_->[0];
         system("chroot $rootimg_dir cp $srcfile $pathinrootimage");
         my $srcpath = "$pathonrootimage/".basename($_->[0]);
         if (-f "$customdir/".$_->[0]) {
            $srcpath="$customdir/".$_->[0];
         } elsif (-f "$pathtofiles/".$_->[0]) {
            $srcpath="$pathtofiles/".$_->[0];
         }
         mkpath(dirname("/tmp/xcatinitrd.$$/".$_->[1]));
         copy($srcpath,"/tmp/xcatinitrd.$$/".$_->[1]);
         chmod 0755,"/tmp/xcatinitrd.$$/".$_->[1];
      } else {
         #print "$_\n";
         system("chroot $rootimg_dir cp $_ $pathinrootimage");
         my $srcpath = "$pathonrootimage/".basename($_);
         if (-f "$customdir/$_") {
            $srcpath = "$customdir/$_";
         } elsif (-f "$pathtofiles/$_") {
            $srcpath = "$pathtofiles/$_";
         }
         mkpath(dirname("/tmp/xcatinitrd.$$/$_"));
         copy("$srcpath","/tmp/xcatinitrd.$$/$_");
         chmod 0755,"/tmp/xcatinitrd.$$/".$_;
      }
   }
   rmtree($pathonrootimage);

   #copy conf files needed by nfs mount in sles11.2
   if($osver_host == 11)
   {
      system("cp -r $rootimg_dir/etc/protocols /tmp/xcatinitrd.$$/etc/");
      system("cp -r $rootimg_dir/etc/netconfig /tmp/xcatinitrd.$$/etc/");
   }
   
   
   # Copy udev libraries
   system("mkdir -p /tmp/xcatinitrd.$$/etc/udev");
   system("mkdir -p /tmp/xcatinitrd.$$/lib/firmware");
   system("cp -r $rootimg_dir/etc/udev/* /tmp/xcatinitrd.$$/etc/udev");
   system("cp -r $rootimg_dir/bin/uname /tmp/xcatinitrd.$$/bin/");
   if ( -d "$rootimg_dir/lib/firmware/" ) {
       system("cp -r $rootimg_dir/lib/firmware/* /tmp/xcatinitrd.$$/lib/firmware");
   }
   system("cp -r $rootimg_dir/usr/bin/killall /tmp/xcatinitrd.$$/usr/bin");
	
	# Copy rules for network adapter
	#my $name = `cat /etc/sysconfig/network/ifcfg-$prinic | grep NAME`;
	#my $nic = '';
	#if ($name =~ m/(\d+\.\d+\.\d+)/g) {
	#	$nic = $&;
	#}

    # Somehow checking for *$nic.rules does not work
    #if ( -f "/etc/udev/rules.d/*$nic.rules" ) {
    #    system("cp -r /etc/udev/rules.d/*$nic.rules /tmp/xcatinitrd.$$/etc/udev/rules.d");
    #}
    #if ( -f "/etc/udev/rules.d/*persistent-net.rules" ) {
    #	    system("cp -r /etc/udev/rules.d/*persistent-net.rules /tmp/xcatinitrd.$$/etc/udev/rules.d");
    #}
	
   system("mkdir -p /tmp/xcatinitrd.$$/lib/udev");
   system("cp -r $rootimg_dir/lib/udev/* /tmp/xcatinitrd.$$/lib/udev");

   #copy("$rootimg_dir/lib/modules/*d","/tmp/xcatinitrd.$$/$_");
   system("cd /tmp/xcatinitrd.$$/bin/; ln -sf bash sh");	#neccessary for SLES11
    if ($mode eq "statelite") {
        system("cd /tmp/xcatinitrd.$$;find .|cpio -H newc -o|gzip -9 -c - > $destdir/initrd-statelite.gz");
        print "The initial ramdisk for statelite has been generated successfully!\n";
    } else {
        system("cd /tmp/xcatinitrd.$$;find .|cpio -H newc -o|gzip -9 -c - > $destdir/initrd-stateless.gz");
        print "The initial ramdisk for statelite has been generated successfully!\n";
    }
   system("rm -rf /tmp/xcatinitrd.$$");

}

sub isyumdir {
   if ($File::Find::name =~ /\/repodata$/) {
      my $location = $File::Find::name;
      $location =~ s/\/repodata$//;
      push @yumdirs,$location;
   }
}

sub isnetdriver {
   foreach (@ndrivers) {
      if ($File::Find::name =~ /\/$_/) {
         my $filetoadd = $File::Find::name;
         $filetoadd =~ s!$rootimg_dir!!;
         push @filestoadd,[$filetoadd,"lib/$_"];
      }
   }
}
      	






sub postscripts { # TODO: customized postscripts
    generic_post();
    unless( -d "$rootimg_dir/opt/xcat/") {
        mkdir "$rootimg_dir/opt/xcat/";
    }
    copy ("$installroot/postscripts/xcatdsklspost", "$rootimg_dir/opt/xcat/"); #TODO: it is not used in stateless
    chmod '0755', "$rootimg_dir/opt/xcat/xcatdsklspost";
}

sub generic_post { # This function is meant to leave the image in a state approximating a normal install
    my $cfgfile;

    #modify /etc/sysconfig/clock in the image:HWCLOCK="--local", TIMEZONE=site:timezone
    if ($timezone) {
        system("sed  -i '".'s!\(TIMEZONE=\).*!\1'."\"$timezone\"!"."' $rootimg_dir/etc/sysconfig/clock");
        system("chroot $rootimg_dir zic -l $timezone");
    }

    system("sed  -i 's!\\(HWCLOCK=\\).*!\\1\"--localtime\"!' $rootimg_dir/etc/sysconfig/clock");

    unlink("$rootimg_dir/dev/null");
    system("mknod $rootimg_dir/dev/null c 1 3");
    open($cfgfile,">","$rootimg_dir/etc/fstab");
    print $cfgfile "devpts  /dev/pts devpts   gid=5,mode=620 0 0\n";
    print $cfgfile "tmpfs   /dev/shm tmpfs    defaults       0 0\n";
    print $cfgfile "proc    /proc    proc     defaults       0 0\n";
    print $cfgfile "sysfs   /sys     sysfs    defaults       0 0\n";
    if ($tmplimit) {
        print $cfgfile "tmpfs   /tmp     tmpfs    defaults,size=$tmplimit       0 2\n";
        print $cfgfile "tmpfs   /var/tmp     tmpfs    defaults,size=$tmplimit       0 2\n";
    } else {
        print $cfgfile "tmpfs   /tmp    tmpfs   defaults,size=10m       0 2\n";
        print $cfgfile "tmpfs   /var/tmp    tmpfs   defaults,size=10m   0 2\n";
    }

    my $rootfs_name = $profile."_".$arch;
    print $cfgfile "$rootfs_name    /   tmpfs   rw  0 1\n";

    close($cfgfile);

    open($cfgfile,">","$rootimg_dir/etc/sysconfig/network");
    print $cfgfile "NETWORKING=yes\n";
    close($cfgfile);

    open($cfgfile,">","$rootimg_dir/etc/resolv.conf");
    print $cfgfile "#Dummy resolv.conf to make boot cleaner";
    close($cfgfile);
    # Create the ifcfg-x file for diskless node. But keep the ONBOOT=no
    # to skip the break of nfs-based boot
    if ($prinic) {
      open($cfgfile,">","$rootimg_dir/etc/sysconfig/network/ifcfg-$prinic");
      print $cfgfile "ONBOOT=no\nBOOTPROTO=dhcp\nDEVICE=$prinic\nSTARTMODE=auto\n";
      close($cfgfile);
    }

    foreach (split /,/,$othernics) {
        next if (/^$/);
        open($cfgfile,">","$rootimg_dir/etc/sysconfig/network/ifcfg-$_");
        print $cfgfile "ONBOOT=yes\nBOOTPROTO=dhcp\nDEVICE=$_\nSTARTMODE=auto\n";
        close($cfgfile);
    }
   
    # securetty not needed on s390x
    if ($arch ne "s390x") {
        open( $cfgfile, ">>", "$rootimg_dir/etc/securetty" );
        print $cfgfile "ttyS0\n";
        print $cfgfile "ttyS1\n";
        print $cfgfile "console\n";
        close($cfgfile);
    }
   
    my @passwd;
    open($cfgfile,"<","$rootimg_dir/etc/passwd");
    @passwd = <$cfgfile>;
    close($cfgfile);
    open($cfgfile,">","$rootimg_dir/etc/passwd");
    foreach (@passwd) {
        if (/^root:/) {
            s/^root:\*/root:x/;
        }
        print $cfgfile $_;
    }
    close($cfgfile);
    foreach (<$rootimg_dir/etc/skel/.*>) {
        next if (basename($_) eq '.' or basename($_) eq '..');
        copy $_,"$rootimg_dir/root/";
    }
   
	# gettyset is not found on s390x
	if ($arch ne "s390x") {
		open( $cfgfile, ">", "$rootimg_dir/etc/init.d/gettyset" );
		print $cfgfile "#!/bin/bash\n";
		print $cfgfile "### BEGIN INIT INFO\n";
		print $cfgfile "# Provides: gettyset\n";
		print $cfgfile "# Required-Start: sshd\n";
		print $cfgfile "# Required-Stop:\n";
		print $cfgfile "# Default-Start: 3\n";
		print $cfgfile "# Default-Stop: 0 1 2 6\n";
		print $cfgfile "# Short-Description: gettyset\n";
		print $cfgfile "# Description:\n";
		print $cfgfile "### END INIT INFO\n";
		print $cfgfile "VERS=`grep VERSION /etc/SuSE-release`\n";
		print $cfgfile "if [ -n \"\$VERS\" ]; then\n";
		print $cfgfile "  VERNUM=`echo \$VERS|awk -F= \'{print \$2}\'|sed -e \'s/ //g\'`\n";
		print $cfgfile "fi\n";
		print $cfgfile "if [ \"\$VERNUM\" -gt 10 ]; then\n";
		print $cfgfile "  exit\n";
		print $cfgfile "fi\n";
		print $cfgfile "\n";
		print $cfgfile "for i in `cat /proc/cmdline`; do\n";
		print $cfgfile '  KEY=`echo $i|cut -d= -f 1`' . "\n";
		print $cfgfile "  if [ \"\$KEY\" == \"console\" -a \"\$i\" != \"console=tty0\" ]; then\n";
		print $cfgfile "    VALUE=`echo \$i | cut -d= -f 2`\n";
		print $cfgfile "     COTTY=`echo \$VALUE|cut -d, -f 1`\n";
		print $cfgfile "     COSPEED=`echo \$VALUE|cut -d, -f 2|cut -dn -f 1`\n";
		print $cfgfile "     if echo \$VALUE | grep n8r; then\n";
		print $cfgfile "        FLOWFLAG=\"-h\"\n";
		print $cfgfile "     fi\n";
		print $cfgfile "     echo xco:2345:respawn:/sbin/agetty \$FLOWFLAG \$COTTY \$COSPEED xterm >> /etc/inittab\n";
		print $cfgfile "     init q\n";
		print $cfgfile "  fi\n";
		print $cfgfile "done\n";
		print $cfgfile "/etc/init.d/boot.localnet start\n";
	
		close($cfgfile);
		chmod( 0755, "$rootimg_dir/etc/init.d/gettyset" );
	}

    copy("$installroot/postscripts/xcatpostinit", "$rootimg_dir/etc/init.d/xcatpostinit");
    chmod(0755, "$rootimg_dir/etc/init.d/xcatpostinit");
    #insserv with -f option to ignore the dependency on sles10.4
    system("chroot $rootimg_dir insserv -f network sshd gettyset xcatpostinit");

    my $rc = system("grep sshd $rootimg_dir/etc/init.d/.depend.start | grep TARGETS");
    if ($rc) {
        system("sed -i '".'s/^\(TARGETS = .*\)$/\1 sshd/'."' $rootimg_dir/etc/init.d/.depend.start");
        system("ln -s ../sshd $rootimg_dir/etc/init.d/rc3.d/S20sshd");
    }
    my $rc = system("grep gettyset $rootimg_dir/etc/init.d/.depend.start | grep TARGETS");
    if ($rc) {
        system("sed -i '".'s/^\(TARGETS = .*\)$/\1 gettyset/'."' $rootimg_dir/etc/init.d/.depend.start");
        system("ln -s ../gettyset $rootimg_dir/etc/init.d/rc3.d/S60gettyset");
    }
}


my $driver_name;
my $real_path;
sub get_path ()
{
    if ($File::Find::name =~ /\/$driver_name/) {
        $real_path = $File::Find::name;
    }
}

my @all_real_path;
sub get_all_path ()
{
    if ($File::Find::name =~ /\/$driver_name/) {
        push @all_real_path, $File::Find::name;
    }
}

# Load driver disk and driver rpm to the initrd
# Get the driver disk or driver rpm from the osimage.driverupdatesrc
# The valid value: dud:/install/dud/dd.img,rpm:/install/rpm/d.rpm, if missing the tag: 'dud'/'rpm'
# the 'rpm' is default.
#
# If cannot find the driver disk from osimage.driverupdatesrc, will try to search driver disk 
# from /install/driverdisk/<os>/<arch>
#
# For driver rpm, the driver list will be gotten from osimage.netdrivers. If not set, copy all the drivers from driver 
# rpm to the initrd.
#
# Return the driver names by loading order

sub load_dd()
{
    my @dd_list;
    my @rpm_list;
    my @driver_list;

    my $Injectalldriver;
    my @rpm_drivers;

    # Parse the parameters to the the source of Driver update disk and Driver rpm, and driver list as well
    if ($driverupdatesrc) {
        my @srcs = split(',', $driverupdatesrc);
        foreach my $src (@srcs) {
            if ($src =~ /dud:(.*)/i) {
                push @dd_list, $1;
            } elsif ($src =~ /rpm:(.*)/i) {
                push @rpm_list, $1;
            } else {
                push @rpm_list, $src;
            }
        }
    }
    if (! @dd_list) {
        # get Driver update disk from the default path if not specified in osimage
        # check the Driver Update Disk images, it can be .img or .iso
        if (-d "$installroot/driverdisk/$osver/$arch") {
            @dd_list = `find $installroot/driverdisk/$osver/$arch -type f`;
        }
    }

    foreach (split /,/,$netdriver) { 
        if (/^allupdate$/) {
            $Injectalldriver = 1;
            next;
        }
        unless (/\.ko$/) {
	    s/$/.ko/;
        }
        push @driver_list, $_;
    }

    chomp(@dd_list);
    chomp(@rpm_list);

    unless (@dd_list || (@rpm_list && ($Injectalldriver || @driver_list))) {
        return ();
    }

    # Create the work space, it should be cleaned at end of genimage
    my $dd_dir = mkdtemp("/tmp/ddtmpXXXXXXX");
    mkpath "$dd_dir/mnt";
    mkpath "$dd_dir/mods";

    my @dd_drivers = ();    #driver names
    
    # Load drivers from each Driver Disk
    # For multiple dd, if want to make it has order, rename the dd with a number
    # ahead of the name like 0_xx, 1_xx
    foreach my $dd (sort(@dd_list)) {
        my $rc = system ("mount -o loop $dd $dd_dir/mnt");
        if ($rc) {
            print "mount the Driver Disk $dd failed.\n";
            next;
        }
    
        mkpath "$dd_dir/full";
        
        # Copy out the drivers
        opendir(DIR, "$dd_dir/mnt") || die "Cannot open dir $dd_dir/mnt";
        while (my $dir = readdir(DIR)) {
            if ($dir =~ /^\./) { next; }

            # Every driver update disk can have multiple directories, each directory
            # has the directory format like /linux/[distribution]/[architechture]-[version]/
            # If the directory name is numeric, then it will be used as order to load the  
            # the dirviers inside.
            # For the directory name which is not numeric, copy them to directory 0. It will be 
            # loaled first.
            if ($dir !~ /^\d*$/) {  
                mkpath "$dd_dir/full/0";
                system ("cp -rf $dd_dir/mnt/$dir $dd_dir/full/0");
            } else {
                system ("cp -rf $dd_dir/mnt/$dir $dd_dir/full/");
            }
        }
        closedir(DIR);
    
        # Get all the kernel modules base on the order of directory name.
        
        # The structure of dd: <order>/linux/[distribution]/[architechture]-[version]/

        # The supported arch: i386, ia64, ppc, ppc64, s390, s390x sparc or x86_64.
        my $darch = $arch;
        if ($darch =~ /^x86$/) {
            $darch = "i386";
        }
        
        # If the version is os version. If the os is "sles11.1", the possible os version
        # could be "sles11.1", "11.1", "11", "sles11"
        my @distro = ($osver);
        my $distro1 = $osver;
        $distro1 =~ s/[^\d]*//;
        push @distro,$distro1;
        my $distro2 = $distro1;
        $distro2 =~ s/\..*//;
        push @distro,$distro2;
        my $distro3 = $osver;
        $distro3 =~ s/\..*//;
        push @distro,$distro3;

        opendir (FDIR, "$dd_dir/full") || die "Cannot open dir $dd_dir/full";
        my @fulldir = readdir(FDIR);
        closedir (FDIR);

        # Create the directory for drivers from driver disk
        if (! -d "$rootimg_dir/lib/modules/$kernelver/kernel/drivers/driverdisk") {
            mkpath "$rootimg_dir/lib/modules/$kernelver/kernel/drivers/driverdisk";
        }

        # Copy the drivers to the root image and get the driver loading order
        foreach my $dir (sort(@fulldir)) {
            if ($dir =~ /^\./) { next; }
            my $vdir;
            foreach (@distro) {
                if (-d "$dd_dir/full/$dir/linux/suse/$darch-$_") {
                    $vdir = "$dd_dir/full/$dir/linux/suse/$darch-$_";
                }
            }
            if (! $vdir) { next; }

            # Use the module_order if it has
            if (-f "$vdir/modules/module.order") {
                open(ORDER, "<", "$vdir/modules/module.order");
                while (my $file = <ORDER>) {
                    chomp ($file);
                    if (-f "$vdir/modules/$file") {
                        $driver_name = $file;
                        $real_path = "";
                        find(\&get_path, <$rootimg_dir/lib/modules/$kernelver/*>);
                        if ($real_path eq "") {
                            system ("cp $vdir/modules/$file $rootimg_dir/lib/modules/$kernelver/kernel/drivers/driverdisk");
                        } else {
                            system ("cp $vdir/modules/$file $real_path");
                        }
                        
                        push @dd_drivers, $file;
                    }
                }
            } else {
                opendir (MDIR, "$vdir/modules") || die "Cannot open dir $vdir/modules";
                while (my $file = readdir(MDIR)) {
                    if (-f "$vdir/modules/$file" && $file =~ /\.ko/) {
                        $driver_name = $file;
                        $real_path = "";
                        find(\&get_path, <$rootimg_dir/lib/modules/$kernelver/*>);
                        if ($real_path eq "") {
                            system ("cp $vdir/modules/$file $rootimg_dir/lib/modules/$kernelver/kernel/drivers/driverdisk");
                        } else {
                            system ("cp $vdir/modules/$file $real_path");
                        }
                        
                        push @dd_drivers, $file;
                    }
                }
            }
        }
    
        rmtree "$dd_dir/full";
    
        my $rc = system ("umount -f $dd_dir/mnt");
        if ($rc) {
            print "umount the directory $dd_dir/mnt failed\n";
            exit 1;
        }
    }

    # Loading the drivers from rpm packages
    if (@rpm_list && ($Injectalldriver || @driver_list)) {
        # Extract the files from rpm to the tmp dir
        mkpath "$dd_dir/rpm";
        foreach my $rpm (@rpm_list) {
            if (-r $rpm) {
                if (system ("cd $dd_dir/rpm; rpm2cpio $rpm | cpio -idum")) {
                    print "Error: Cannot extract the files from the rpm $rpm.\n";
                }
            } else {
                print "Error: Cannot read the rpm $rpm.\n";
            }
        }

        # To skip the conflict of files that some rpm uses the xxx.ko.new as the name of the driver
        # Change it back to xxx.ko here
        $driver_name = "\*ko.new";
        @all_real_path = ();
        find(\&get_all_path, <$dd_dir/rpm/*>);
        foreach my $file (@all_real_path) {
            my $newname = $file;
            $newname =~ s/\.new$//;
            if (system ("mv -f $file $newname")) {
                print "Error: Could not rename $file\n";

            }
        }

        # Copy the firmware to the rootimage
        if (-d "$dd_dir/rpm/lib/firmware") {
            system ("cp -rf $dd_dir/rpm/lib/firmware $rootimg_dir/lib");
        }
        # Copy the drivers to the rootimage
        if (-d "$dd_dir/rpm/lib/modules/$kernelver") {
          #mkpath "$rootimg_dir/lib/modules/$kernelver/updates/";
          if (@driver_list) {
            foreach my $driver (@driver_list) {
              $driver_name = $driver;
              $real_path = "";
              find(\&get_path, <$dd_dir/rpm/lib/modules/$kernelver/*>);
              if ($real_path && $real_path =~ m!$dd_dir/rpm(/lib/modules/$kernelver/.*?)[^\/]*$!) {
                  # remove the old one if existing
                  @all_real_path = ();
                  find(\&get_all_path, <$rootimg_dir/lib/modules/$kernelver/*>);
                  foreach (@all_real_path) {
                      if (-r $_) {
                          unlink ($_);
                      }
                  }
                  
                  if (! -d "$rootimg_dir$1") {
                      mkpath "$rootimg_dir$1";
                  }
                  system ("cp -rf $real_path $rootimg_dir$1");
                  push @rpm_drivers, $driver;
              } else {
                  print "Error: cannot find the driver $driver from the driver rpms\n";
              }
            }
          } elsif ($Injectalldriver) {
            # copy all the drviers to the rootimage
            find(\&get_all_path, <$dd_dir/rpm/lib/modules/$kernelver/*>);
            my @all_drivers = @all_real_path;
            foreach my $new_driver (@all_drivers) {
              if (basename($new_driver) =~ /\.ko$/) {
                  # remove the old one if existing
                  $driver_name = basename($new_driver);
                  @all_real_path = ();
                  find(\&get_all_path, <$rootimg_dir/lib/modules/$kernelver/*>);
                  foreach my $old_driver (@all_real_path) {
                      if (-r $old_driver) {
                          unlink ($old_driver);
                      }
                  }
                  push @rpm_drivers, basename($new_driver);
              }
            }
            
            system ("cp -rf $dd_dir/rpm/lib/modules/$kernelver $rootimg_dir/lib/modules/");
          }
        } else {
          print "Warning: cannot find the kernel $kernelver from drvier rpms\n";
        }

        push @dd_drivers, @rpm_drivers;
    }
    
    # Generate the dependency relationship
    system ("chroot '$rootimg_dir' depmod $kernelver");

    # Clean the env
    rmtree "$dd_dir";

    return @dd_drivers;
}

sub usage {
    print 'Usage: genimage  -o <OSVER> [-a <arch>] -p <profile> -i <nodebootif> -n <nodenetdrivers> [-r <otherifaces>] [-k <kernelver>] [-g <krpmver>] [-l rootlimitsize] [--permission <permission>] [--interactive]'."\n";
    print "       --permission is used for statelite only\n";
    print "Examples:\n";
    print " genimage -i eth0 -n tg3 -o sles11 -p compute\n";
    print " genimage -i eth0 -r eth1,eth2 -n tg3,bnx2 -o sles11 -p compute --interactive\n";
    print " genimage -i eth0 -n tg3,bnx2 -o sles11 -p compute\n";
    print " genimage -i eth0 -n tg3,bnx2 -o sles11 -p compute --permission 777\n";
    return 0;
}
