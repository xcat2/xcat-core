#!/bin/bash
#
# go-release - A tool for the xCAT release process checking
#
# Version 0.0.1
#
# Copyright (C) 2017 International Business Machines
# Eclipse Public License, Version 1.0 (EPL-1.0)
#     <http://www.eclipse.org/legal/epl-v10.html>
#
# 2017-12-21 GONG Jie <gongjie@linux.vnet.ibm.com>
#     - Initial release
#

function usage()
{
	local script="${0##*/}"
	local version="$(version)"

	while read -r ; do echo "${REPLY}" ; done <<-EOF
	${script} version ${version}

	Usage: ${script} [xCAT version]
	A tool for the xCAT release process checking

	Examples:
	  ${script} 2.13.10

	xCAT (Extreme Cloud/Cluster Administration Toolkit): <http://xcat.org/>
	Full documentation at: <http://xcat-docs.readthedocs.io/en/stable/>
	EOF
}

#
# version		Print out the version number.
#
function version()
{
	# Read the first ten lines of this script
	for i in {0..9}
	do
		read -r
		[[ ${REPLY} =~ \#\ +[Vv]ersion ]] && echo "${REPLY##* }" && return 0
	done <"$0"
	return 1
}

PATH="/usr/bin:/usr/sbin:/bin:/sbin"

for d in "/opt/local/bin" "/opt/local/sbin"
do
	[ -d "${d}" ] && PATH="${PATH}:${d}"
done
for d in "/opt/local/libexec/gnubin"
do
	[ -d "${d}" ] && PATH="${d}:${PATH}"
done

export PATH

#
# warn_if_bad		Put out warning message(s) if $1 has bad RC.
#
#	$1	0 (pass) or non-zero (fail).
#	$2+	Remaining arguments printed only if the $1 is non-zero.
#
#	Incoming $1 is returned unless it is 0
#
function warn_if_bad()
{
	local -i rc="$1"
	local script="${0##*/}"

	# Ignore if no problems
	[ "${rc}" -eq "0" ] && return 0

	# Broken
	shift
	echo "${script}: $@" >&2
	return "${rc}"
}

#
# exit_if_bad		Put out error message(s) if $1 has bad RC.
#
#	$1	0 (pass) or non-zero (fail).
#	$2+	Remaining arguments printed only if the $1 is non-zero.
#
#               Exits with 1 unless $1 is 0
#
function exit_if_bad()
{
	warn_if_bad "$@" || exit 1
	return 0
}

#
# check_root_or_exit
#
#	Breaks the script if not running as root.
#
#	If this returns 1, the invoker MUST abort the script.
#
#	Returns 0 if running as root
#	Returns 1 if not (and breaks the script)
#
function check_root_or_exit()
{
	[ "${UID}" -eq "0" ]
	exit_if_bad "$?" "Must be run by UID=0. Actual UID=${UID}."
	return 0
}

#
# check_executes	Check for executable(s)
#
#	Returns 0 if true.
#	Returns 1 if not.
#
function check_executes()
{
	local cmd
	local all_ok="yes"
	for cmd in "$@"
	do
		if ! type "${cmd}" &>/dev/null
		then
			echo "Command \"${cmd}\" not found." >&2
			all_ok="no"
		fi
	done
	[ "${all_ok}" = "yes" ]
}

#
# check_exec_or_exit	Check for required executables.
#
#	Exits (not returns) if commands listed on command line do not exist.
#
#	Returns 0 if true.
#	Exits with 1 if not.
#
function check_exec_or_exit()
{
	check_executes "$@"
	exit_if_bad "$?" "Above listed required command(s) not found."
	return 0
}

TMP_DIR=""

#
# internal_setup	Script setup
#
#	Returns 0 on success.
#	Exits (not returns) with 1 on failure.
#
function internal_setup()
{
	shopt -s extglob

	# Trap exit for internal_cleanup function.
	trap "internal_cleanup" EXIT

	check_exec_or_exit mktemp rm

	umask 0077

	TMP_DIR="$(mktemp -d "/tmp/${0##*/}.XXXXXXXX" 2>/dev/null)"
	[ -d "${TMP_DIR}" ]
	exit_if_bad "$?" "Make temporary directory failed."

	custom_setup
}

#
# internal_cleanup	Script cleanup (reached via trap 0)
#
#	Destory any temporarily facility created by internal_setup.
#
function internal_cleanup()
{
	custom_cleanup

	[ -d "${TMP_DIR}" ] && rm -rf "${TMP_DIR}"
}

#
# custom_setup
#
function custom_setup()
{
	check_exec_or_exit git wget

	local color_prompt

	if type tput >/dev/null 2>&1 &&
		( tput setf 1 >/dev/null 2>&1 || tput setaf 1 >/dev/null 2>&1 )
	then
		# We have color support; assume it's compliant with Ecma-48
		# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
		# a case would tend to support setf rather than setaf.)
		color_prompt=yes
	else
		color_prompt=
	fi

	if [ "${color_prompt}" = "yes" ]
	then
		RES_COL=70
		MOVE_TO_COL="echo -en \\033[${RES_COL}G"
		SETCOLOR_SUCCESS="echo -en \\033[1;32m"
		SETCOLOR_FAILURE="echo -en \\033[1;31m"
		SETCOLOR_WARNING="echo -en \\033[1;33m"
		SETCOLOR_ERROR="echo -en \\033[1;38m"
		SETCOLOR_NOTICE="echo -en \\033[1;36m"
		SETCOLOR_DEBUG="echo -en \\033[1;34m"
		SETCOLOR_INFORMATION="echo -en \\033[1;30m"
		SETCOLOR_NORMAL="echo -en \\033[0;39m"
	fi
}

#
# custom_cleanup
#
function custom_cleanup()
{
	:
}

#
# cleanup_n_exec	Do the cleanup, then execute the command
#
#	$1+	The command to execute
#
function cleanup_n_exec()
{
	internal_cleanup

	exec "$@"
}

internal_setup

GO_RELEASE_METERS=""

function show_progress_meters()
{
	$MOVE_TO_COL
	[[ -t 2 ]] || return 0
	# Show the progress meters
	(
		declare -i length=0
		while :
		do
			for bar in \
				"........ " \
				"o....... " \
				"Oo...... " \
				"OOo..... " \
				"oOOo.... " \
				".oOOo... " \
				"..oOOo.. " \
				"...oOOo. " \
				"....oOOo " \
				".....oOO " \
				"......oO " \
				".......o " \
				"........ "
				#12345678901234567890123456789012345678901
			do
				msg="${bar}"
				for (( i = 0; i < length; ++i ))
				do
					echo -ne "\b"
				done
				length=${#msg}
				echo -n "${msg}"

				sleep 0.1 2>/dev/null || sleep 1
				kill -0 "$$" >/dev/null 2>&1 || break 2
			done
		done
	) >&2 &
	GO_RELEASE_METERS="$!"
	disown "${GO_RELEASE_METERS}"
}

function stop_progress_meters()
{
	if [[ -t 2 ]]
	then
		kill "${GO_RELEASE_METERS}" >/dev/null 2>&1
		echo -ne "\b\b\b\b\b\b\b\b\b" >&2
	fi
	echo -n "........ "
}

function echo_success()
{
	$MOVE_TO_COL
	echo -n "["
	$SETCOLOR_SUCCESS
	echo -n $"  OK  "
	$SETCOLOR_NORMAL
	echo -n "]"
	echo -ne "\r"
	return 0
}

function echo_failure() {
	$MOVE_TO_COL
	echo -n "["
	$SETCOLOR_FAILURE
	echo -n $"FAILED"
	$SETCOLOR_NORMAL
	echo -n "]"
	echo -ne "\r"
	return 1
}

function echo_passed() {
	$MOVE_TO_COL
	echo -n "["
	$SETCOLOR_WARNING
	echo -n $"PASSED"
	$SETCOLOR_NORMAL
	echo -n "]"
	echo -ne "\r"
	return 1
}

function echo_warning() {
	$MOVE_TO_COL
	echo -n "["
	$SETCOLOR_WARNING
	echo -n $"WARNING"
	$SETCOLOR_NORMAL
	echo -n "]"
	echo -ne "\r"
	return 1
}

function download_file()
{
	local script="${0##*/}"
	local version="$(version)"
	local user_agent="${script}/${version}"
	type wget >/dev/null 2>&1 || return 255
	local url="$1"
	local local_file="$2"
	local log_file="${TMP_DIR}/wget.log.${RANDOM}"
	local -i rc=0
	wget -U "${user_agent}" -nv "${url}" -O "${local_file}" -o "${log_file}"
	rc="$?"
	if [[ "${rc}" -ne "0" ]]
	then
		while read -r ; do echo "${REPLY}" ; done <"${log_file}"
		echo -n "${script}: \`wget' exited with an error: (exit code ${rc}, "
		case "${rc}" in
		1) echo -n "generic error" ;;
		2) echo -n "parse error" ;;
		3) echo -n "file I/O error" ;;
		4) echo -n "network failure" ;;
		5) echo -n "SSL verification failure" ;;
		6) echo -n "username/password authentication failure" ;;
		7) echo -n "protocol errors" ;;
		8) echo -n "server issued an error response" ;;
		*) echo -n "unknown error" ;;
		esac
		echo ")"
		echo "  ... while downloading \`${url}'"
	fi >&2
	[[ "${rc}" -eq "0" ]]
}

TEST_0000="0.0 xCAT Version Number"

function go_release_test_0000_version_number()
{
	local version="$1"
	local old_ifs="${IFS}"

	echo "${version}" >&4

	IFS="."
	set -- $version
	IFS="${old_ifs}"

	[ "$#" -le "3" ]
	exit_if_bad "$?" "Incorrect xCAT version number - 0x00"

	[[ $1 =~ ^[1-9][0-9]*$ ]]
	exit_if_bad "$?" "Incorrect xCAT version number - 0x01"
	[[ $2 =~ ^[0-9]+$ ]]
	exit_if_bad "$?" "Incorrect xCAT version number - 0x02"
	[[ $3 =~ ^[0-9]*$ ]]
	exit_if_bad "$?" "Incorrect xCAT version number - 0x03"
}

TEST_0010="0.1 Get a Clone Copy of xcat-core Git Repository"

XCAT_CORE_GIT_REPO="https://github.com/xcat2/xcat-core.git"
XCAT_CORE_GIT_DIR="/tmp/src/xcat-core"

function go_release_test_0010_git_clone()
{
	local version="$1"
	
	# Update git repo
	if [ -d "${XCAT_CORE_GIT_DIR}" ]
	then
		(
			cd "${XCAT_CORE_GIT_DIR}"
			git checkout master 2>&1
			warn_if_bad "$?" "Command \`git checkout' failed"
			git fetch origin 2>&1
			exit_if_bad "$?" "Command \`git fetch' failed"
			git pull origin master 2>&1
			warn_if_bad "$?" "Command \`git pull' failed"
			# Delete all other branches except the `master' branch
			git branch | grep -v '^*' | xargs -r -n 1 git branch -D 2>&1
		)
	else
		mkdir -p "${XCAT_CORE_GIT_DIR%/*}"
		git clone "${XCAT_CORE_GIT_REPO}" "${xcat_core_git_dir}"
		exit_if_bad "$?" "Command \`git clone' failed"
	fi
}

TEST_0110="1.1 Check \`docs/source/conf.py'"

function go_release_test_0110_conf_py()
{
	local version="$1"
	local file="docs/source/conf.py"

	(	
		cd "${XCAT_CORE_GIT_DIR}"
		git checkout master 2>&1
		warn_if_bad "$?" "Command \`git checkout' failed"

		[ -f "${file}" ]
		exit_if_bad "$?" "File not found - \`${file}'"

		head -n 99 "${file}" | grep -q "^release = '${version}'$"
		if [ "$?" -ne "0" ]
		then
			head -n 99 "${file}" | grep "^release =" >&3
			false
		fi
		exit_if_bad "$?" "Incorrect release version in file - \`${file}'"
	)
}

TEST_0120="1.2 Check \`docs/source/overview/xcat2_release.rst'"

function go_release_test_0120_xcat2_release_rst()
{
	local version="$1"
	local file="docs/source/overview/xcat2_release.rst"

	(	
		cd "${XCAT_CORE_GIT_DIR}"
		git checkout master 2>&1
		warn_if_bad "$?" "Command \`git checkout' failed"

		[ -f "${file}" ]
		exit_if_bad "$?" "File not found - \`${file}'"

		head -n 99 "${file}" | grep -q "^|| xCAT ${version} "
		warn_if_bad "$?" "Release information need to be updated"
		exit_if_bad "$?" "- \`${file}' - 0x01"
		head -n 99 "${file}" | grep -q "^| \`${version} Release Notes "
		warn_if_bad "$?" "Release information need to be updated"
		exit_if_bad "$?" "- \`${file}' - 0x02"
	)
}

TEST_0130="1.3 xCAT Release Information"

function go_release_test_0130_release_information()
{
	local version="$1"
	local url="https://github.com/xcat2/xcat-core/wiki/XCAT_${version}_Release_Notes"
	local release_notes="${TMP_DIR}/release_notes"

	download_file "${url}" "${release_notes}"
	exit_if_bad "$?" "Download release notes failed"

	# Check the HTML <title> line
	grep -q -E "<title>XCAT_${version//./\\.}_Release_Notes.*</title>" "${release_notes}"
	exit_if_bad "$?" "The web page of release notes do not have a correct HTML title"

	# Check the HTML <h1> line
	grep -q -E "<h1 .*>XCAT_${version//./\\.}_Release_Notes</h1>" "${release_notes}"
	exit_if_bad "$?" "The web page of release notes do not have a correct H1 title"
}

TEST_0710="7.1 Tag the Release in GitHub Web Page"

function go_release_test_0710_release_notes()
{
	local version="$1"
	local url="https://github.com/xcat2/xcat-core/wiki/XCAT_${version}_Release_Notes"
	local release_notes="${TMP_DIR}/release_notes"

	download_file "${url}" "${release_notes}"
	exit_if_bad "$?" "Download release notes failed"

	# Check the HTML <title> line
	grep -q -E "<title>XCAT_${version//./\\.}_Release_Notes.*</title>" "${release_notes}"
	exit_if_bad "$?" "The web page of release notes do not have a correct HTML title"

	# Check the HTML <h1> line
	grep -q -E "<h1 .*>XCAT_${version//./\\.}_Release_Notes</h1>" "${release_notes}"
	exit_if_bad "$?" "The web page of release notes do not have a correct H1 title"
}

TEST_0720="7.2 Tag Code in the Release Branch"

function go_release_test_0720_release_branch()
{
	sleep 5
	:
}

XCAT_VERSION="$1"

if [ -z "${XCAT_VERSION}" ]
then
	usage
	exit 1
fi

for t in $(compgen -A function "go_release_test_")
do
	tag="${t#go_release_test_}"
	tag="${tag%%_*}"
	a_test="TEST_${tag}"
	a_test="${!a_test}"
	[ -z "${a_test}" ] && a_test="${t#go_release_test_}"
	echo -n "${a_test}"
	show_progress_meters
	(
		"${t}" "${XCAT_VERSION}"
	) >"${TMP_DIR}/${t}.stdout" \
	 2>"${TMP_DIR}/${t}.stderr" \
	 3>"${TMP_DIR}/${t}.notice" \
	 4>"${TMP_DIR}/${t}.debug"
	RET="$?"
	stop_progress_meters
	case "${RET}" in
	"0")
		echo_success
		;;
	"254")
		echo_warning
		;;
	"255")
		echo_passed
		;;
	*)
		echo_failure
		;;
	esac
	echo
	case "${RET}" in
	"0")
		;;
	*)
		sed -e "s/^.*$/$(${SETCOLOR_INFORMATION})\0$(${SETCOLOR_NORMAL})/" \
			-e 's/^/    /' <"${TMP_DIR}/${t}.stdout"
		;;
	esac
	sed -e "s/^.*$/$(${SETCOLOR_DEBUG})\0$(${SETCOLOR_NORMAL})/" \
		-e 's/^/    + /' <"${TMP_DIR}/${t}.debug"
	sed -e "s/^.*$/$(${SETCOLOR_NOTICE})\0$(${SETCOLOR_NORMAL})/" \
		-e 's/^/    > /' <"${TMP_DIR}/${t}.notice"
	sed -e "s/^${0##*/}: /${tag}: /" \
		-e "s/^.*$/$(${SETCOLOR_ERROR})\0$(${SETCOLOR_NORMAL})/" \
		-e 's/^/    /' <"${TMP_DIR}/${t}.stderr"
done
